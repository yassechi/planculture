import { ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { UpdateBoardDTO } from './dtos/update.board.dto';
import { CreateBoardDTO } from './dtos/create.board.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { Board } from 'src/entities/board.entity';
import { Sole } from 'src/entities/sole.entity';
import { Repository } from 'typeorm';

@Injectable()
export class BoardService {
  constructor(
    @InjectRepository(Board)
    private readonly boardRepository: Repository<Board>,
    @InjectRepository(Sole)
    private readonly soleRepository: Repository<Sole>,
  ) {}

  /**
   *
   * @returns
   */
  public async getAllBoards() {
    return this.boardRepository.find({
      relations: {
        sectionPlans: {
          sections: {
            vegetable: true,
          },
        },
      },
    });
  }

  /**
   *
   * @param id
   * @returns
   */
  async getBoardById(id: number): Promise<Board | null> {
    return this.boardRepository.findOne({
      where: { id_board: id },
      relations: {
        sectionPlans: {
          sections: {
            vegetable: true,
          },
        },
      },
    });
  }

  /**
   *
   * @param id
   * @returns
   */
  async createBoard(dto: CreateBoardDTO): Promise<Board> {
    const existingBoard = await this.boardRepository.findOne({
      where: {
        board_name: dto.board_name,
        board_active: true,
      },
    });

    if (existingBoard) {
      throw new ConflictException('Une planche avec le même nom existe déjà');
    }

    // 2️⃣ Créer la board
    const board = this.boardRepository.create({
      board_name: dto.board_name,
      board_width: dto.board_width,
      board_length: dto.board_length,
      board_active: dto.board_active,
      id_sole: dto.id_sole,
    });

    return this.boardRepository.save(board);
  }
  /**
   *
   * @param id
   * @returns
   */
  async updateBoard(payload: UpdateBoardDTO): Promise<Board> {
    const { id_board, id_sole, ...rest } = payload;
    const board = await this.boardRepository.findOne({ where: { id_board } });

    if (!board) {
      throw new NotFoundException(`Board with id ${id_board} does not exist`);
    }

    if (id_sole && id_sole !== board.id_sole) {
      const sole = await this.soleRepository.findOne({
        where: { id_sole },
      });

      // return exception SQL pas mon retour Custom
      if (!sole) {
        throw new NotFoundException(`Sole with id ${id_sole} does not exist`);
        // return {msg: `Sole with id ${id_sole} does not exist`} as any;
      }

      board.id_sole = id_sole;
    }
    Object.assign(board, rest);
    return await this.boardRepository.save(board);
  }

  /**
   *
   * @param id
   * @returns
   */
  async delBoard(id: number): Promise<{ msg: string }> {
    const user = await this.boardRepository.findOne({
      where: { id_board: id },
    });

    if (!user) {
      throw new NotFoundException('Planche introuvable');
    }
    await this.boardRepository.delete({ id_board: id });
    return { msg: 'Planche supprimé avec succès' };
  }
}
